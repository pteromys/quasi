<!doctype html>
<html lang="en">
<head>
	<title>Quasicrystals</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style type="text/css">
		html, body { width: 100%; height: 100%; margin: 0px; padding: 0px; }
		body { background: #000; }
		canvas { width: 100%; height: 100%; display: block; }
		.overlay {
			position: absolute;
			top: 1em; bottom: 2em; left: 1em; right: 1em;
			margin: 0em; padding: 0em;
			text-align: center;
			display: none;
		}
		.overlay:target {
			display: block;
		}
		.box {
			display: inline-block;
			vertical-align: middle;
			background: #333;
			color: #fff;
			padding: 0.5em 1.5em;
			max-width: 25em;
			text-align: left;
			border-radius: 1em;
			overflow-y: auto;
			max-height: 100%;
		}
		.box p {
			line-height: 1.5;
			margin: 1em 0em;
		}
		.box a:link { color: #7bf; }
		.box a:visited { color: #d7f; }
		.box a:hover { color: #bdf; }
		.box a:active { color: #ffc; }
		.button {
			font-family: sans;
			font-weight: bold;
			font-size: 200%;
			width: 1em;
			height: 1em;
			margin: 0.5em;
			color: #fff;
			background: #666;
			background: rgba(255, 255, 255, 0.25);
			opacity: 0.8;
			border-radius: 0.5em;
		}
		.button:hover {
			opacity: 1.0;
		}
		.button > a, .box .button > a {
			color: inherit;
			text-decoration: none;
			display: block;
			width: 1em;
			height: 1em;
			text-align: center;
			line-height: 1em;
		}
		body > .button {
			position: absolute;
			bottom: 0.25em;
			right: 0.25em;
		}
		.box .button {
			float: right;
			margin-right: -0.5em;
			margin-top: 0em;
		}
	</style>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript" src="heap.js"></script>
	<script type="text/javascript" src="motion.js"></script>
	<script type="text/javascript">
		window.requestAnimFrame =
			window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function (callback, element) {
				window.setTimeout(function () {
					return callback((new Date()).valueOf() + 16);
				}, 16);
			};
		var next_frame = null;
		var fillCircle = function (context, x, y, r) {
			context.beginPath();
			context.arc(x, y, r, 0, Math.PI*2, true);
			context.fill();
		};
		var EPSILON = 1e-9;
		// Vector and Matrix operations
		var V = {
			dot: function (x, y) {
				var ans = 0;
				for (var i = Math.min(x.length, y.length) - 1; i >= 0; i--) {
					ans += x[i] * y[i];
				}
				return ans;
			},
			scale: function (v, a) {
				return v.map(function (x) { return x * a; });
			},
			add: function (x, y) {
				var ans = new Array(Math.min(x.length, y.length));
				for (var i = 0; i < ans.length; i++) {
					ans[i] = x[i] + y[i];
				}
				return ans;
			},
			zero: function (n) {
				var ans = new Array(n);
				for (var i = 0; i < n; i++) { ans[i] = 0; }
				return ans;
			},
			isZero: function (v) {
				for (var i = 0; i < v.length; i++) {
					if (v[i] != 0) {
						return false;
					}
				}
				return true;
			},
		};
		var M = {
			mul: function (m, v) {
				var ans = V.zero(m.length);
				for (var i = 0; i < ans.length; i++) {
					for (var j = 0; j < v.length; j++) {
						ans[i] += m[i][j] * v[j];
					}
				}
				return ans;
			},
		};
		var Vertex = function (indices, quasilattice) {
			this.lattice = quasilattice;
			this.indices = indices.slice(); // Make a copy
			this.xy = quasilattice.xy(indices);
			this.displacement = quasilattice.displacement(indices, this.xy);
			this.xy2 = V.dot(this.xy, this.xy);
			this.d2 = V.dot(this.displacement, this.displacement);
			this.r2 = this.d2 / quasilattice.variance;
			this.is_border = true;
		};
		Vertex.prototype = {
			toString: function () {
				return this.indices.join(' ');
			},
			weight: function () {
				//return 0.2 * this.xy2 + this.d2;
				// Empirically, it doesn't seem necessary to go more than 3
				// standard deviations out in order to fill local space
				// with visibles. Visible threshold, set arbitrarily at dot size/50,
				// is at sqrt(-4 ln 0.02), approximately 3.956.
				// To go down to 1/100th of dot size is about 4.292.
				return 2 * this.xy2 / this.lattice.r2 + this.r2;
			},
		};
		var QuasiLattice = function (n, target_radius) { // n = degree of symmetry
			this.n = n;
			this.radius = target_radius || 5;
			this.r2 = this.radius * this.radius;
			this.achieved_radius = false;
			this.exhausted_verts = false;
			this.weight_threshold = Math.pow(Math.sqrt(-4 * Math.log(this.radius/100)) - 1, 2);
			// Some constants
			this.variance = Math.pow(this.n, 1/(this.n - 3)) * 0.5 / Math.PI;
			this.dotsize = 0.2;
			// 2D basis elements
			this.x = V.zero(n);
			this.y = V.zero(n);
			var norm = Math.sqrt(2/n);
			for (var i = 0; i < n; i++) {
				this.x[i] = Math.cos(2 * Math.PI * i / n) * norm;
				this.y[i] = Math.sin(2 * Math.PI * i / n) * norm;
			}
			// Vertex list
			this.verts = [new Vertex(V.zero(n), this)];
			this.border_verts = new Heap(this.verts, this.vertCmp);
			this.vert_names = {};
			this.vert_names[this.verts[0].toString()] = this.verts[0];
			// Set up translation directions
			this.directions = new Array(2*n);
			for (var i = 0; i < n; i++) {
				this.directions[i] = V.zero(n);
				this.directions[i][i] = 1;
				this.directions[i][(i+1)%n] = -1;
				this.directions[i+n] = V.zero(n);
				this.directions[i+n][i] = -1;
				this.directions[i+n][(i+1)%n] = 1;
			}
			for (var i = 0; i < this.directions.length; i++) {
				this.directions[i] = new Vertex(this.directions[i], this);
			}
			this.direction_threshold = Infinity;
		};
		QuasiLattice.prototype = {
			displacement: function (indices, xy) {
				var v = indices.slice();
				for (var i = 0; i < v.length; i++) {
					v[i] -= this.x[i] * xy[0] + this.y[i] * xy[1];
				}
				return v;
			},
			xy: function (indices) {
				return [V.dot(this.x, indices), V.dot(this.y, indices)];
			},
			vertCmp: function (a, b) {
				// Return true if a is a nicer vert to search from than b.
				if (typeof(b) == 'undefined') { return true; }
				if (typeof(a) == 'undefined') { return false; }
				return (a.weight() < b.weight());
			},
			addVerts: function (v) {
				// Search through neighbors of a border vertex v.
				// Automatically select v from the queue if not given.
				if (!v) {
					v = this.border_verts.pop();
					if (!v || (this.achieved_radius && v.weight() > this.weight_threshold)) {
						this.exhausted_verts = true;
						return false;
					}
				}
				var nv;
				for (var i = 0; i < this.directions.length; i++) {
					nv = this.addVert(V.add(v.indices, this.directions[i].indices));
					if (nv) {
						nv.prev = v;
						if (nv.xy2 > this.r2) {
							this.achieved_radius = true;
						};
					}
				}
				v.is_border = false;
				return true;
			},
			addVert: function (indices) {
				if (this.vert_names[indices.join(' ')]) { return false; }
				var nv = new Vertex(indices, this);
				var r2 = V.dot(nv.displacement, nv.displacement) / this.variance;
				if (r2 > 16) { return false; }
				this.verts.push(nv);
				this.border_verts.push(nv);
				this.vert_names[nv.toString()] = nv;
				if (nv.weight() < this.directions[0].weight() - EPSILON) {
					this.direction_threshold = this.directions[0].weight();
				}
				if (nv.weight() < this.direction_threshold + EPSILON) {
					this.directions.unshift(nv);
				}
				return nv;
			},
			getGradient: function (context) {
				if (this.gradient) { return this.gradient; }
				this.gradient = context.createRadialGradient(0, 0, 0, 0, 0, 1);
				this.gradient.addColorStop(0, '#fff');
				this.gradient.addColorStop(0.5, '#ff0');
				this.gradient.addColorStop(1, '#000');
				return this.gradient;
			},
			draw: function (context, xy_view, offset, scale) {
				// Set up context
				var m = context.canvas;
				var w = context.canvas.width = window.innerWidth;
				var h = context.canvas.height = window.innerHeight;
				var r = Math.sqrt(w*w + h*h)/2;
				context = context.canvas.getContext('2d');
				context.fillStyle = this.getGradient(context);
				context.globalCompositeOperation = 'lighter';
				context.translate(context.canvas.width/2, context.canvas.height/2);
				scale = (scale || 1) * r / this.radius;
				context.scale(scale, scale);
				var visibles = 0;
				for (var j = 0; j < this.verts.length; j++) {
					context.save();
					var xy = V.add(xy_view, V.add(this.verts[j].xy, offset.xy));
					var scl = V.add(this.verts[j].displacement, offset.displacement);
					scl = this.dotsize * Math.exp(-0.25 * V.dot(scl, scl) / this.variance);
					if (scl > 0.5/50) { visibles += 1; }
					context.translate(xy[0], xy[1]);
					context.scale(scl, scl);
					context.fillRect(-1, -1, 2, 2);
					context.restore();
				}
				return visibles;
			},
		};
		$(document).ready(function () {
			var m = document.getElementById('main');
			window.q = new QuasiLattice(11);
			window.movable = new Movable();
			movable.bindHandlers(window);
			movable.v_walk = 0.003;
			movable.moveFromTo = function (a, b) {
				this.position[0] += (b[0] - a[0]) * 5 / q.r;
				this.position[1] += (b[1] - a[1]) * 5 / q.r;
			};
			var t_0 = null;
			var offset = new Vertex(V.zero(q.n), q);
			var cmpTranslators = function (a, b) {
				axy = V.add(movable.position, V.add(a.xy, offset.xy));
				ad = V.add(offset.displacement, a.displacement);
				bxy = V.add(movable.position, V.add(b.xy, offset.xy));
				bd = V.add(offset.displacement, b.displacement);
				axy = Math.max(0, V.dot(axy, axy) - 6.25);
				ad = V.dot(ad, ad);
				bxy = Math.max(0, V.dot(bxy, bxy) - 6.25);
				bd = V.dot(bd, bd);
				return (ad - bd) + (axy - bxy);
			};
			var draw = function (time_scheduled, single_frame) {
				next_frame = null;
				var want_another_frame = false;
				if (!t_0) { t_0 = time_scheduled; }
				// Arrow key motion
				var dt = 16;
				if (t_0 && time_scheduled) {
					dt = time_scheduled - t_0;
				}
				dt = Math.min(dt, 300);
				dt = dt || 16;
				t_0 = null;
				movable.update(dt);
				if (movable.isMoving()) {
					want_another_frame = true;
				}
				// Draw
				q.draw(m.getContext('2d'), movable.position, offset, 1);
				// Add verts
				if (!q.exhausted_verts) {
					q.addVerts();
					$('#worst').text(q.verts.length + ' ' + q.border_verts.items[0].weight());
					want_another_frame = true;
				}
				// Translate
				var translator = q.verts[0];
				for (var i = 0; i < q.directions.length; i++) {
					if (cmpTranslators(translator, q.directions[i]) > 0) {
						translator = q.directions[i];
					}
				}
				offset = new Vertex(V.add(offset.indices, translator.indices), q);
				if (!V.isZero(translator.indices)) { want_another_frame = true; }
				// Request next frame
				if (!single_frame && want_another_frame && !next_frame) {
					next_frame = window.requestAnimFrame(draw);
				}
			};
			movable.motionCallback = function () {
				if (!next_frame) {
					next_frame = window.requestAnimFrame(draw);
				}
			};
			$('#helpbutton').on('click', function (e) {
				e.stopPropagation();
				if (window.location.hash == '#help') {
					e.preventDefault();
					window.location = '#';
				}
			});
			window.draw = draw;
			draw();
		});
	</script>
</head>
<body>
	<canvas id="main">
		<img src="quasi-thumbnail.png" alt="Preview" />
		This demo requires HTML5 Canvas support.
	</canvas>
	<div id="worst" style="position: absolute; z-index: 10; width: 10em; height: 1em; left:0px; top:0px; color: #fff;"></div>
	<div id="help" class="overlay">
		<div class="box">
			<div class="button"><a href="#">&times;</a></div>
			<p>This page draws patterns reminiscient of quasicrystals
			by projecting higher-dimensional lattices into the plane.
			<p>Code written by <a href="http://pteromys.melonisland.net/">Pteromys</a>
			and released under the <a href="http://unlicense.org/">Unlicense</a>.</p>
		</div>
	</div>
	<div class="button"><a href="#help" id="helpbutton">?</a></div>
</body>
</html>
