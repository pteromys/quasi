<!doctype html>
<html lang="en">
<head>
	<title>Quasicrystals</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style type="text/css">
		html, body { width: 100%; height: 100%; margin: 0px; padding: 0px; }
		body { background: #000; }
		canvas { width: 100%; height: 100%; display: block; }
		.overlay {
			position: absolute;
			top: 1em; bottom: 2em; left: 1em; right: 1em;
			margin: 0em; padding: 0em;
			text-align: center;
			display: none;
		}
		.overlay:target {
			display: block;
		}
		.box {
			display: inline-block;
			vertical-align: middle;
			background: #333;
			color: #fff;
			padding: 0.5em 1.5em;
			max-width: 25em;
			text-align: left;
			border-radius: 1em;
			overflow-y: auto;
			max-height: 100%;
		}
		.box p {
			line-height: 1.5;
			margin: 1em 0em;
		}
		.box a:link { color: #7bf; }
		.box a:visited { color: #d7f; }
		.box a:hover { color: #bdf; }
		.box a:active { color: #ffc; }
		.button {
			font-family: sans;
			font-weight: bold;
			font-size: 200%;
			width: 1em;
			height: 1em;
			margin: 0.5em;
			color: #fff;
			background: #666;
			background: rgba(255, 255, 255, 0.25);
			opacity: 0.8;
			border-radius: 0.5em;
		}
		.button:hover {
			opacity: 1.0;
		}
		.button > a, .box .button > a {
			color: inherit;
			text-decoration: none;
			display: block;
			width: 1em;
			height: 1em;
			text-align: center;
			line-height: 1em;
		}
		body > .button {
			position: absolute;
			bottom: 0.25em;
			right: 0.25em;
		}
		.box .button {
			float: right;
			margin-right: -0.5em;
			margin-top: 0em;
		}
	</style>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript">
		window.requestAnimFrame =
			window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function (callback, element) {
				window.setTimeout(function () {
					return callback((new Date()).valueOf() + 16);
				}, 16);
			};
		var next_frame = null;
		var fillCircle = function (context, x, y, r) {
			context.beginPath();
			context.arc(x, y, r, 0, Math.PI*2, true);
			context.fill();
		};
		var EPSILON = 1e-9;
		// Vector and Matrix operations
		var V = {
			dot: function (x, y) {
				var ans = 0;
				for (var i = Math.min(x.length, y.length) - 1; i >= 0; i--) {
					ans += x[i] * y[i];
				}
				return ans;
			},
			scale: function (v, a) {
				return v.map(function (x) { return x * a; });
			},
			add: function (x, y) {
				var ans = new Array(Math.min(x.length, y.length));
				for (var i = 0; i < ans.length; i++) {
					ans[i] = x[i] + y[i];
				}
				return ans;
			},
			zero: function (n) {
				var ans = new Array(n);
				for (var i = 0; i < n; i++) { ans[i] = 0; }
				return ans;
			},
		};
		var M = {
			mul: function (m, v) {
				var ans = V.zero(m.length);
				for (var i = 0; i < ans.length; i++) {
					for (var j = 0; j < v.length; j++) {
						ans[i] += m[i][j] * v[j];
					}
				}
				return ans;
			},
		};
		var Heap = function (items, comparator) {
			if (!(this instanceof Heap)) { return new Heap(items, comparator); }
			// A zero-indexed min-heap.
			this.cmp = comparator;
			this.items = [];
			for (var i = 0; i < items.length; i++) {
				this.push(items[i]);
			}
		};
		Heap.prototype = {
			push: function (item) {
				// Push an item onto the root of the heap
				var k = 0;
				var swap = null;
				while (true) {
					if (typeof(this.items[k]) == 'undefined') {
						this.items[k] = item;
						break;
					}
					if (this.cmp(item, this.items[k])) {
						swap = this.items[k];
						this.items[k] = item;
						item = swap;
					}
					k = 2*k + 1;
					if (this.cmp(this.items[k], this.items[k+1]) ||
							(typeof(this.items[k+1]) == 'undefined')) {
						k++;
					}
				}
			},
			pop: function (replacement) {
				var k = 0;
				var j = 0;
				var swap = null;
				var item = this.items[0];
				this.items[0] = replacement;
				while (true) {
					j = 2 * k + 1;
					if (this.cmp(this.items[j+1], this.items[j]) ||
							(typeof(this.items[j]) == 'undefined')) {
						j++;
					}
					if (this.cmp(this.items[k], this.items[j]) ||
							(typeof(this.items[j]) == 'undefined')) {
						break;
					}
					swap = this.items[k];
					this.items[k] = this.items[j];
					this.items[j] = swap;
					k = j;
				}
				//if (typeof(this.items[k]) == 'undefined') { delete this.items[k]; }
				return item;
			},
			check: function () {
				for (var i = 0; i < this.items.length; i++) {
					for (var k = 2*i + 1; k <= 2*i + 2; k++) {
						if (this.cmp(this.items[k], this.items[i])) { return k; }
						if (typeof(this.items[k]) != 'undefined' && typeof(this.items[i]) == 'undefined') { return k; }
					}
				}
			},
		};
		var Vertex = function (indices, quasilattice) {
			this.lattice = quasilattice;
			this.indices = indices.slice(); // Make a copy
			this.xy = quasilattice.xy(indices);
			this.displacement = quasilattice.displacement(indices, this.xy);
			this.xy2 = V.dot(this.xy, this.xy);
			this.d2 = V.dot(this.displacement, this.displacement);
			this.r2 = this.d2 / quasilattice.variance;
			this.is_border = true;
		};
		Vertex.prototype.toString = function () {
			return this.indices.join(' ');
		};
		var QuasiLattice = function (n) { // n = degree of symmetry
			this.n = n;
			// 2D basis elements
			this.x = V.zero(n);
			this.y = V.zero(n);
			this.dx = V.zero(n-1);
			this.dy = V.zero(n-1);
			var norm = Math.sqrt(2/n);
			for (var i = 0; i < n; i++) {
				this.x[i] = Math.cos(2 * Math.PI * i / n) * norm;
				this.y[i] = Math.sin(2 * Math.PI * i / n) * norm;
			}
			for (var i = 0; i < n - 1; i++) {
				this.dx[i] = this.x[i] - this.x[i+1];
				this.dy[i] = this.y[i] - this.y[i+1];
			}
			// Vertex list
			this.verts = [new Vertex(V.zero(n-1), this)];
			this.border_verts = new Heap(this.verts, this.vertCmp);
			this.vert_names = {};
			this.vert_names[this.verts[0].toString()] = this.verts[0];
			this.translators = [this.verts[0]];
			this.newest_translators = [this.verts[0]];
			this.best_translator = Infinity;
			// Other constants
			this.variance = Math.pow(this.n, 1/(this.n - 3)) * 0.5 / Math.PI;
			this.dotsize = 0.2;
		};
		QuasiLattice.prototype = {
			displacement: function (indices, xy) {
				var v = V.zero(this.n);
				for (var i = 0; i < this.n - 1; i++) {
					v[i] += indices[i];
					v[i+1] -= indices[i];
				}
				for (var i = 0; i < v.length; i++) {
					v[i] -= this.x[i] * xy[0] + this.y[i] * xy[1];
				}
				return v;
			},
			xy: function (indices) {
				return [V.dot(this.dx, indices), V.dot(this.dy, indices)];
			},
			vertCmp: function (a, b) {
				// Return true if a is a nicer vert to search from than b.
				if (typeof(b) == 'undefined') { return true; }
				if (typeof(a) == 'undefined') { return false; }
				a = 0.1 * Math.max(a.xy2 - 25, 0) + a.d2;
				b = 0.1 * Math.max(b.xy2 - 25, 0) + b.d2;
				return (a < b);
			},
			addVerts: function (v) {
				// Search through neighbors of a border vertex v.
				// Automatically select v from the queue if not given.
				if (!v) {
					//if (!this.border_verts.length) { return false; }
					//v = this.border_verts.shift();
					v = this.border_verts.pop();
					if (!v) { return false; }
				}
				var nv;
				var indices, indices2;
				for (var i = 0; i < this.n - 1; i++) {
					indices = v.indices.slice();
					indices2 = v.indices.slice();
					indices[i] += 1;
					indices2[i] -= 1;
					nv = this.addVert(indices);
					if (nv) { nv.prev = v; }
					nv = this.addVert(indices2);
					if (nv) { nv.prev = v; }
				}
				indices = v.indices.slice();
				indices2 = v.indices.slice();
				for (var j = 0; j < this.n - 1; j++) {
					indices[j] += 1;
					indices2[j] -= 1;
				}
				nv = this.addVert(indices);
				if (nv) { nv.prev = v; }
				nv = this.addVert(indices2);
				if (nv) { nv.prev = v; }
				v.is_border = false;
				return true;
			},
			addVert: function (indices) {
				if (this.vert_names[indices.join(' ')]) { return false; }
				var nv = new Vertex(indices, this);
				var r2 = V.dot(nv.displacement, nv.displacement) / this.variance;
				if (r2 > 16) { return false; }
				this.verts.push(nv);
				this.border_verts.push(nv);
				this.vert_names[nv.toString()] = nv;
				if (r2 < this.best_translator - EPSILON) {
					this.best_translator = r2;
					this.translators = this.newest_translators;
					this.newest_translators = [this.verts[0]];
				}
				if (r2 < this.best_translator + EPSILON) {
					this.translators.push(nv);
					this.newest_translators.push(nv);
				}
				return nv;
			},
			addVertsLayer: function () {
				return false;
				var n = this.border_verts.length;
				for (var i = 0; i < n; i++) {
					this.addVerts();
				}
				return this.border_verts.length;
			},
			addVertsDouble: function () {
				return false;
				var startv = this.verts.length;
				var startb = this.border_verts.length;
				var rebordered = false;
				if (startb == 0) {
					this.border_verts = this.verts;
					startb = this.border_verts.length;
					rebordered = true;
				}
				var new_border = [];
				for (var i = 0; i < startb; i++) {
					for (var j = 0; j < startv; j++) {
						var indices = this.border_verts[i].indices.slice();
						for (var k = 0; k < this.n - 1; k++) {
							indices[k] += this.verts[j].indices[k];
						}
						var nv = this.addVert(indices);
						if ((nv && this.verts[j].is_border) || rebordered) {
							new_border.push(nv);
						}
					}
				}
				for (var i = 0; i < this.border_verts.length; i++) {
					this.border_verts[i].is_border = false;
				}
				for (var i = 0; i < new_border.length; i++) {
					new_border[i].is_border = true;
				}
				this.border_verts = new_border;
			},
			getGradient: function (context) {
				if (this.gradient) { return this.gradient; }
				this.gradient = context.createRadialGradient(0, 0, 0, 0, 0, 1);
				this.gradient.addColorStop(0, '#fff');
				this.gradient.addColorStop(0.5, '#ff0');
				this.gradient.addColorStop(1, '#000');
				return this.gradient;
			},
			check: function () {
				var vl = [];
				var nl = {};
				for (var i = 0; i < this.verts.length; i++) {
					var n = V.zero(this.n);
					for (var j = 0; j < this.n - 1; j++) {
						n[j] += q.verts[i].indices[j];
						n[j+1] -= q.verts[i].indices[j];
					}
					vl.push(n);
					nl[n.join(' ')] = true;
				}
				var missing = [];
				for (var i = 0; i < vl.length; i++) {
					var n = vl[i].slice();
					n.push(n.shift());
					if (! nl[n.join(' ')]) {
						missing.push(n);
					}
				}
				return missing;
			},
			draw: function (context, xy_view, offset, scale) {
				// Set up context
				var m = context.canvas;
				var w = context.canvas.width = window.innerWidth;
				var h = context.canvas.height = window.innerHeight;
				var r = Math.sqrt(w*w + h*h)/2;
				context = context.canvas.getContext('2d');
				context.fillStyle = this.getGradient(context);
				context.globalCompositeOperation = 'lighter';
				context.translate(context.canvas.width/2, context.canvas.height/2);
				scale = (scale || 1) * r/5;
				context.scale(scale, scale);
				var visibles = 0;
				for (var j = 0; j < this.verts.length; j++) {
					context.save();
					var xy = V.add(xy_view, V.add(this.verts[j].xy, offset.xy));
					var scl = V.add(this.verts[j].displacement, offset.displacement);
					scl = this.dotsize * Math.exp(-0.25 * V.dot(scl, scl) / this.variance);
					if (scl > 0.5/50) { visibles += 1; }
					context.translate(xy[0], xy[1]);
					context.scale(scl, scl);
					context.fillRect(-1, -1, 2, 2);
					context.restore();
				}
				return visibles;
			},
		};
		window.velocity = [0, 0];
		var KEYS = {
			"ESC": 27,
			"SPACE": 32,
			"LEFT": 37,
			"UP": 38,
			"RIGHT": 39,
			"DOWN": 40,
			"QUESTION": 191,
		}
		var keys_down = {
			"37": false,
			"38": false,
			"39": false,
			"40": false,
			"mouse": false,
		};
		var updateVelocity = function (dt) {
			dt = dt || 16;
			var dv = 0.00003 * dt;
			var vmax = 0.0025;
			var decay = 0.000025 * dt;
			var clampAndDecay = function (t) {
				if (t < -decay) { t += decay; }
				else if (t > decay) { t -= decay; }
				else { t = 0; }
				return Math.max(-vmax, Math.min(t, vmax));
			};
			// Only apply arrow key motion if no dialogs are active
			//if (!isModalDialogActive()) {
				if (keys_down[KEYS.UP]) { window.velocity[1] += dv; }
				if (keys_down[KEYS.DOWN]) { window.velocity[1] -= dv; }
				if (keys_down[KEYS.LEFT]) { window.velocity[0] -= dv; }
				if (keys_down[KEYS.RIGHT]) { window.velocity[0] += dv; }
			//}
			window.velocity = window.velocity.map(clampAndDecay);
		};

		window.onload = function () {
			window.q = new QuasiLattice(11);
			var m = document.getElementById('main');
			//q.draw(document.getElementById('main').getContext('2d'), 1);
			var t_0 = null;
			var offset = new Vertex(V.zero(q.n - 1), q);
			var xy = [0, 0];
			var cmpTranslators = function (a, b) {
				axy = V.add(xy, V.add(a.xy, offset.xy));
				ad = V.add(offset.displacement, a.displacement);
				bxy = V.add(xy, V.add(b.xy, offset.xy));
				bd = V.add(offset.displacement, b.displacement);
				axy = V.dot(axy, axy);
				ad = V.dot(ad, ad);
				bxy = V.dot(bxy, bxy);
				bd = V.dot(bd, bd);
				return (ad - bd) * 5 + (axy - bxy);
			};
			var draw = function (time_scheduled, single_frame) {
				next_frame = null;
				var want_another_frame = false;
				if (!t_0) { t_0 = time_scheduled; }
				// Arrow key motion
				var dt = 16;
				if (t_0 && time_scheduled) {
					dt = time_scheduled - t_0;
				}
				dt = Math.min(dt, 300);
				dt = dt || 16;
				t_0 = null;
				updateVelocity(dt);
				if (window.velocity[0] || window.velocity[1] ||
						keys_down[KEYS.UP] || keys_down[KEYS.DOWN] ||
						keys_down[KEYS.LEFT] || keys_down[KEYS.RIGHT]) {
					xy[0] -= window.velocity[0] * dt;
					xy[1] += window.velocity[1] * dt;
					want_another_frame = true;
				}
				// Draw
				q.draw(m.getContext('2d'), xy, offset, 1);
				// Add verts
				if (q.verts.length < 5000) {
					q.addVerts() || q.addVertsDouble();
					want_another_frame = true;
				}
				// Translate
				q.translators.sort(cmpTranslators);
				offset = new Vertex(V.add(offset.indices, q.translators[0].indices), q);
				// Request next frame
				if (!single_frame && want_another_frame) {
					next_frame = window.requestAnimFrame(draw);
				}
			};
			window.onkeydown = function (e) {
				if (typeof(keys_down[e.which]) != 'undefined') {
					keys_down[e.which] = true;
				}
				if (!next_frame) {
					next_frame = window.requestAnimFrame(draw);
				}
			};
			window.onresize = function (e) {
				if (!next_frame) {
					next_frame = window.requestAnimFrame(draw);
				}
			};
			window.onkeyup = function (e) {
				if (typeof(keys_down[e.which]) != 'undefined') {
					keys_down[e.which] = false;
				}
			};
			window.onblur = window.onmouseout = function (e) {
				for (k in keys_down) {
					keys_down[k] = false;
				}
			}
			window.xy = xy;
			window.draw = draw;
			draw();
		};

		/*
		var randomColor = function () {
			var c = [Math.random(), Math.random(), Math.random()];
			var scale = 255 / (1 - Math.min.apply(null, c));
			for (var i = 0; i < 3; i++) {
				c[i] = Math.round((1 - c[i]) * scale);
			}
			return 'rgb(' + c.join(',') + ')';
		};
		var Star = function (min_radius, max_radius) {
			var theta = Math.random() * Math.PI * 2;
			var r = Math.exp(Math.random() * Math.log(max_radius/min_radius)) * min_radius;
			this.color = randomColor();
			this.x = r * Math.cos(theta);
			this.y = r * Math.sin(theta);
		};
		Star.prototype = {
			draw: function (context, width, scale_0, scale_1) {
				var dx = -this.y * width;
				var dy = this.x * width;
				var x = this.x + dx/2;
				var y = this.y + dy/2;
				context.beginPath();
				context.fillStyle = this.color;
				context.moveTo(x * scale_0, y * scale_0);
				context.lineTo(x * scale_1, y * scale_1);
				context.lineTo((x - dx) * scale_1, (y - dy) * scale_1);
				context.lineTo((x - dx) * scale_0, (y - dy) * scale_0);
				context.closePath();
				context.fill();
			},
			r2: function () {
				return this.x * this.x + this.y * this.y;
			},
		};
		window.onload = function () {
			var epsilon = 2;
			var e2 = epsilon * epsilon;
			var stars = [];
			var t_0 = null;
			var scale_prev = 1;
			var backwards = false;
			var draw = function (time_scheduled, single_frame) {
				if (!t_0) { t_0 = time_scheduled; }
				var m = document.getElementById('main');
				var c = m.getContext('2d');
				var w = m.width;
				var h = m.height;
				var rx = w/2;
				var ry = h/2;
				var r2 = rx*rx + ry*ry;
				var r = Math.sqrt(r2);
				var scale_new = (time_scheduled - t_0) / 5000;
				if (!backwards) {
					scale_new = 1 - scale_new;
				}
				var s2 = scale_new * scale_new;
				var starsize = 1/Math.sqrt(stars.length);
				var resetDraw = function (bgcolor) {
					bgcolor = bgcolor || 'rgba(0, 0, 0, 0.25)';
					c.fillStyle = bgcolor;
					c.fillRect(-rx, -ry, w, h);
					c.fillStyle = '#fff';
					c.beginPath();
					c.moveTo(epsilon, 0);
					c.arc(0, 0, epsilon, 0, Math.PI);
					c.arc(0, 0, epsilon, Math.PI, 0);
					c.fill();
				};
				c.save();
				c.translate(rx, ry);
				if (scale_new >= 0 && scale_new <= 1) {
					resetDraw('rgba(0, 0, 0, 0.25)');
					for (var i = 0; i < stars.length; i++) {
						var scale_inner = Math.min(scale_prev, scale_new);
						var scale_outer = Math.max(scale_prev, scale_new);
						stars[i].draw(c, starsize, Math.max(scale_outer, scale_inner * (1 + starsize)), scale_inner);
						var d2 = stars[i].r2() * s2;
						if (backwards) {
							var d2 = r2 / s2;
							while (stars[i].r2() > d2) {
								stars[i].x *= epsilon/r;
								stars[i].y *= epsilon/r;
							}
						} else {
							var d2 = e2 / s2;
							while (stars[i].r2() < d2) {
								stars[i].x *= r/epsilon;
								stars[i].y *= r/epsilon;
							}
						}
					}
					scale_prev = scale_new;
					if (!(single_frame === true)) {
						window.requestAnimFrame(draw);
					}
				} else {
					if (backwards || (scale_new < -0.1)) {
						t_0 = null;
						backwards = !backwards;
						if (scale_new < 0) {
							resetDraw('#000');
						}
					} else {
						resetDraw('rgba(0, 0, 0, 0.25)');
						if (!(single_frame === true)) {
							window.requestAnimFrame(draw);
						}
					}
				}
				c.restore();
			};
			var act = function (e) {
				if (e && e.target && e.target.nodeName == 'A') { return true; }
				if (t_0) { return true; }
				var m = document.getElementById('main');
				var c = m.getContext('2d');
				var w = m.width = window.innerWidth;
				var h = m.height = window.innerHeight;
				var rx = w/2;
				var ry = h/2;
				var r = Math.sqrt(rx*rx + ry*ry);
				if (stars.length) {
					window.requestAnimFrame(draw);
				} else {
					for (var i = 0; i < 100; i++) {
						stars.push(new Star(epsilon, r));
					}
					draw(0, true);
				}
			};
			window.onkeydown = act;
			document.getElementById('main').onclick = act;
			document.getElementById('helpbutton').onclick = function () {
				if (window.location.hash == '#help') {
					window.location = '#';
					return false;
				}
			};
			window.draw = draw;
			act();
		};*/
	</script>
</head>
<body>
	<canvas id="main">
		<img src="quasi-thumbnail.png" alt="Preview" />
		This demo requires HTML5 Canvas support.
	</canvas>
	<div id="help" class="overlay">
		<div class="box">
			<div class="button"><a href="#">&times;</a></div>
			<p>This page draws patterns reminiscient of quasicrystals
			by projecting higher-dimensional lattices into the plane.
			<p>Code written by <a href="http://pteromys.melonisland.net/">Pteromys</a>
			and released under the <a href="http://unlicense.org/">Unlicense</a>.</p>
		</div>
	</div>
	<div class="button"><a href="#help" id="helpbutton">?</a></div>
</body>
</html>
