<!doctype html>
<html lang="en">
<head>
	<title>Quasicrystal 3D</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="icons/webfont.css" />
	<link rel="stylesheet" type="text/css" href="interface.css" />
	<style type="text/css">
		html, body {
			width: 100%; height: 100%; margin: 0px; padding: 0px;
			overflow: hidden;
		}
		body { background: #000; }
		canvas {
			position: absolute;
			top: 0px; left: 0px; bottom: 0px; right: 0px;
		}
		#config .box { text-align: center; }
		.box {
			background: rgba(15, 15, 15, 0.9);
			box-shadow: 0em 0em 2em 0em rgba(255, 255, 255, 0.5);
		}
		h2 { text-align: center; }
		#help h2 { text-align: left; }
		.formline { margin: 0.5em -1em 0em; }
		.formline .button { margin: 0em 0.25em; }
	</style>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript" src="hammer.min.js"></script>
	<script type="text/javascript" src="linear.js"></script>
	<script type="text/javascript" src="motion.js"></script>
	<script type="text/javascript" src="frames.js"></script>
	<script type="text/javascript" src="interface.js"></script>
	<script type="text/javascript" src="gl.js"></script>
	<script type="text/javascript">
		var awaitFlags = function (target_flags, func) {
			// Run func once, when all target_flags have been hit.
			// Optionally, set .done to a function that will be
			// passed the return value of func.
			var already_run = 0;
			var flags_hit = 0;
			var f = function (flag) {
				if (already_run) { return; }
				flags_hit |= flag;
				if ((flags_hit & target_flags) == target_flags) {
					already_run = 1;
					return f.done(func());
				}
			};
			f.done = function (x) { return x; };
			return f;
		};
		var fillCircle = function (context, x, y, r) {
			context.beginPath();
			context.arc(x, y, r, 0, Math.PI*2, true);
			context.fill();
		};
		var setupMovable = function () {
			var m = new Movable();
			m.velocity_keys[1] = [m.KEYS.DOWN, m.KEYS.UP]; // invert y-axis
			m.velocity_keys[2] = [m.KEYS.Z, m.KEYS.SPACE]; // flying around
			m.velocity_keys[3] = [189, 187]; // minus and plus
			m.velocity_keys[4] = [173, 61]; // gecko minus and plus
			m.velocity_keys[5] = [109, 107]; // possibly older gecko
			m.velocity_keys[6] = ['nothing', 'press']; // fly by press and hold
			m.velocity_keys[7] = [m.KEYS['<'], m.KEYS['>']]; // rolling the view
			m.canAccelerate = function () {
				return !($('.overlay').is(':target'));
			};
			m.isMovingSuper = m.isMoving;
			m.isMoving = function () {
				if (this.keys_down['press']) { return true; }
				if (!(V.isZero(this.uOriginExtra))) { return true; }
				if (this.is_hammer_busy) { return false; }
				return this.isMovingSuper();
			};
			m.moveResetSuper = m.moveReset;
			m.moveReset = function () {
				this.moveResetSuper();
				this.radius = this.radius || 2;
				this.uDotSize = this.uDotSize || 0.2;
				this.uVariance = this.uVariance || 0.4;
				this.scale = 1.0;
				this.uOrigin = [0, 0, 0];
				this.uOriginExtra = [0, 0, 0];
				this.uOriginColor = [0, 0, 0];
				this.uFog = [10, -1];
				this.uMVMatrix = [
					[1,0,0,0],
					[0,1,0,0],
					[0,0,1,0],
					[0,0,0,1]
				];
				this.uBTMatrix = [
					[1,0,0,0],
					[0,1,0,0],
					[0,0,1,-this.radius],
					[0,0,0,1]
				];
			};
			m.moveTurn = function (yaw, pitch, roll) {
				yaw = yaw || 0;
				pitch = pitch || 0;
				roll = roll || 0;
				var cxz = Math.cos(yaw);
				var sxz = Math.sin(yaw);
				var czy = Math.cos(pitch);
				var szy = Math.sin(pitch);
				var cxy = Math.cos(roll);
				var sxy = Math.sin(roll);
				this.uMVMatrix = M.mulMats(M.mulMats([
						[cxy, sxy, 0, 0],
						[-sxy, cxy,  0, 0],
						[0,   0,    1, 0],
						[0,   0,    0, 1],
					], [
						[cxz,        0,    sxz,       0],
						[-sxz * szy, czy,  cxz * szy, 0],
						[-sxz * czy, -szy, cxz * czy, 0], // -this.radius,
						[0,          0,    0,         1],
				]), this.uMVMatrix);
			};
			m.moveFly = function (distance) {
				this.uOrigin = V.add(
					M.mul(M.transpose(this.uMVMatrix),
						[0, 0, distance / this.scale]),
					this.uOrigin);
			};
			m.moveZoom = function (amount) {
				this.scale = this.scale || 1.0;
				this.scale *= amount;
			};
			m.MAX_SCALE = 2 + Math.sqrt(5);
			m.translators = [];
			m.moveAdjust = function () {
				// Rezooming
				var s2 = this.scale * this.scale;
				if (s2 > this.MAX_SCALE) {
					this.scale /= this.MAX_SCALE;
					this.uOrigin = V.scale(this.uOrigin, this.MAX_SCALE);
					this.uOriginExtra = V.scale(this.uOriginExtra, this.MAX_SCALE);
					this.uOriginColor = V.scale(this.uOriginColor, -1/this.MAX_SCALE);
				} else if (s2 * this.MAX_SCALE < 1) {
					this.scale *= this.MAX_SCALE;
					this.uOrigin = V.scale(this.uOrigin, 1/this.MAX_SCALE);
					this.uOriginExtra = V.scale(this.uOriginExtra, 1/this.MAX_SCALE);
					this.uOriginColor = V.scale(this.uOriginColor, -this.MAX_SCALE);
				}
				// Viewpoint yoinging
				var dist_extra = Math.sqrt(V.dot(this.uOriginExtra, this.uOriginExtra));
				if ((!dist_extra) || (dist_extra <= 0.01)) {
					this.uOriginExtra = [0, 0, 0];
				} else if (dist_extra <= 0.1) {
					this.uOriginExtra = V.scale(this.uOriginExtra, 1 - 0.005/dist_extra);
				} else {
					this.uOriginExtra = V.scale(this.uOriginExtra, 0.95);
				}
				// Recentering
				if (!this.disable_recentering) {
					s2 = this.scale * this.scale;
					function dirNiceness(v) {
						var x = V.add(v.origin, m.uOrigin);
						var y = V.add(v.color, m.uOriginColor);
						x = V.dot(x, x) * s2;
						y = V.dot(y, y) / s2;
						return x + 9 * y;
					}
					var new_niceness = Infinity;
					var niceness = Infinity;
					if (this.translators.length) {
						var dir = this.translators[0];
						for (var i = 0; i < this.translators.length; i++) {
							new_niceness = dirNiceness(this.translators[i]);
							if (new_niceness < niceness) {
								dir = this.translators[i];
								niceness = new_niceness;
							}
						}
						if (dir != this.translators[0]) {
							this.uOrigin = V.add(dir.origin, this.uOrigin);
							this.uOriginColor = V.add(dir.color, this.uOriginColor);
						}
					}
				}
			};
			m.move = function (dt) {
				// Rotation
				if (this.keys_down['press']) {
					var cx = $(window).width()/2;
					var cy = $(window).height()/2;
					var last = getLast();
					this.velocity[0] = 0.6 * (last.centerX - cx) / this.screen_diameter || 0;
					this.velocity[1] = 0.6 * (last.centerY - cy) / this.screen_diameter || 0;
				}
				var yaw = 0.003 * this.velocity[0] * dt;
				var pitch = -0.003 * this.velocity[1] * dt;
				var roll = 0.003 * this.velocity[7] * dt;
				this.moveTurn(yaw, pitch, roll);
				// Translation
				var vfly = this.velocity[2] + this.velocity[6];
				if (vfly) {
					this.moveFly(dt * vfly * 0.005);
				}
				// Zooming
				var vzoom = this.velocity[3] + this.velocity[4] + this.velocity[5];
				if (vzoom) {
					this.moveZoom(Math.exp(dt * vzoom * 0.002));
				}
			};
			m.moveReset();
			var getLast = function () {
				if (!h.session.movableLastParams) {
					h.session.movableLastParams = { pointers: -1 };
				}
				return h.session.movableLastParams;
			};
			var h = new Hammer.Manager($('#main')[0]);
			h.add(new Hammer.Pan({threshold: 0, pointers: 0}));
			h.add(new Hammer.Rotate({threshold: 0}).recognizeWith(h.get('pan')));
			h.add(new Hammer.Pinch({threshold: 0}).recognizeWith([h.get('pan'), h.get('rotate')]));
			h.add(new Hammer.Press({threshold: 10}).recognizeWith(h.get('pan')));
			h.add(new Hammer.Tap({event: 'tripletap', taps: 3}).recognizeWith(h.get('pan')));
			h.add(new Hammer.Tap({event: 'doubletap', taps: 2}).recognizeWith(h.get('pan')).requireFailure(h.get('tripletap')));
			h.on('pan pinch rotate', function (e) {
				var last = getLast();
				var yaw = 0;
				var pitch = 0;
				// Avoid sudden jumps when a finger is added or removed
				if (last.pointers == e.pointers.length) {
					var dt = e.deltaTime - last.deltaTime;
					if (dt) { // Only move if this isn't a duplicate event
						// Rotation
						if (!m.keys_down['press']) {
							yaw = -1.5 * (e.deltaX - last.deltaX) / m.screen_diameter;
							pitch = 1.5 * (e.deltaY - last.deltaY) / m.screen_diameter;
						}
						var roll = ((540 + e.rotation - last.rotation) % 360 - 180) * Math.PI / 180;
						// Inhibit sudden 180-degree flip if fingers get swapped
						if (!(Math.abs(roll) < 1.5)) { roll = 0; }
						m.moveTurn(yaw, pitch, roll);
						// Zooming
						var s = e.scale/last.scale;
						if (!(s > 0.1 && s < 10)) { s = 1; }
						m.moveZoom(s);
						// Set coasting velocities averaging over the last 100ms
						var inertia = Math.max(0, 1 - 0.01 * dt);
						m.velocity[0] = inertia * m.velocity[0] +
							(1 - inertia) * yaw / (dt * 0.003);
						m.velocity[1] = inertia * m.velocity[1] -
							(1 - inertia) * pitch / (dt * 0.003);
						m.velocity[7] = inertia * m.velocity[7] +
							(1 - inertia) * roll / (dt * 0.003);
						m.velocity[3] = inertia * m.velocity[3] +
							(1 - inertia) * (s - 1) / (dt * 0.002);
					}
				}
				// Save data for next time
				last.deltaTime = e.deltaTime;
				last.deltaX = e.deltaX;
				last.deltaY = e.deltaY;
				last.centerX = e.center.x;
				last.centerY = e.center.y;
				last.rotation = e.rotation;
				last.scale = e.scale;
				last.pointers = e.pointers.length;
				m.decay_rate = m.decay_coast;
				if (!e.isFinal) { m.is_hammer_busy = true; }
				m.motionCallback();
			});
			h.on('press', function (e) {
				m.keys_down['press'] = true;
				m.decay_rate = m.decay_coast;
				m.motionCallback();
			});
			h.on('doubletap', function (e) {
				var i = window.glc.pick(
					e.center.x/$(window).width(),
					e.center.y/$(window).height()
				);
				window.movable.selection = i;
				if (!i) { return; }
				// Move origin
				var new_origin = Array.prototype.slice.apply(glc.glData,
					[(i-1)*6*11, (i-1)*6*11 + 3]);
				window.movable.uOriginExtra = V.add(V.add(
					window.movable.uOriginExtra,
					window.movable.uOrigin),
					new_origin);
				window.movable.uOrigin = V.scale(new_origin, -1);
				window.movable.velocity[2] = window.movable.velocity[6] = 0;
				window.frame_manager.requestFrame();
			});
			h.on('tripletap', function (e) {
				if (window.movable.uBTMatrix[2][3]) {
					window.movable.uBTMatrix[2][3] = 0;
					r = -window.movable.radius;
				} else {
					window.movable.uBTMatrix[2][3] = -window.movable.radius;
					r = window.movable.radius;
				}
				// Animate transition
				window.movable.uOriginExtra = V.add(
					window.movable.uOriginExtra,
					M.mul(M.transpose(window.movable.uMVMatrix),
						[0, 0, r]));
				window.frame_manager.requestFrame();
			});
			$('#main').on('wheel DOMMouseScroll mousewheel', function (e) {
				e = e.originalEvent;
				var delta_y = e.wheelDelta || (-e.detail);
				if (Math.abs(delta_y) > 20) { delta_y /= 120; }
				m.velocity[3] = delta_y;
				m.decay_rate = m.decay_coast;
				m.motionCallback();
			});
			$(window).on('mouseup mouseleave touchcancel touchend touchleave',
				function (e) {
					m.is_hammer_busy = false;
					m.keys_down['press'] = false;
				});
			m.hammer = h;
			m.bindHandlers(window);
			$(window).off('.mMouse');
			return m;
		};

		$(document).ready(function () {
			// Init buttons
			ButtonSystem.activateKeys({191: '#button_help'});
			ButtonSystem.activateClickouts();
			// Motion
			window.movable = setupMovable();
			// Animation
			var glc = new GLWrapper();
			// Set up
			glc.glData = new Float32Array([]);
			glc.mem_limit = undefined;
			glc.num_verts = 0;
			glc.num_verts_avail = 0;
			glc.upLOD = function () {
				if (this.num_verts < this.num_verts_avail) {
					this.num_verts = Math.min(this.num_verts_avail, 2 * this.num_verts);
				}
			};
			glc.downLOD = function () {
				this.num_verts = 6 * Math.ceil(this.num_verts/12);
			};
			glc.oom = function () {
				var e;
				while (e = this.gl.getError()) {
					if (e == this.gl.OUT_OF_MEMORY) { return true; }
				}
				return false;
			};
			glc.updateData = function (num_verts, glData) {
				var gl = this.gl;
				var t = this;
				function saveData(glData) {
					t.glData = glData.subarray(0, t.mem_limit || glData.length);
					t.num_verts = t.num_verts_avail = t.glData.length/11;
				}
				saveData(glData);
				if (gl) {
					gl.bindBuffer(gl.ARRAY_BUFFER, this.vertex_buffer);
					gl.bufferData(gl.ARRAY_BUFFER, this.glData, gl.STATIC_DRAW);
					while (this.oom()) {
						this.memory_full = true;
						this.mem_limit = 66 * Math.ceil((this.mem_limit || glData.length)/132);
						saveData(glData);
						this.setupCallback();
					}
					window.frame_manager.requestFrame();
				}
			};
			glc.setupCallback = function () {
				var gl = this.gl;
				gl.clearColor(0, 0, 0, 0);
				gl.enable(gl.BLEND);
				gl.disable(gl.DEPTH_TEST);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
				gl.depthFunc(gl.LEQUAL);
				// Upload data
				this.vertex_buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertex_buffer);
				gl.bufferData(gl.ARRAY_BUFFER, this.glData, gl.STATIC_DRAW);
				this.frame_buffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, this.frame_buffer);
				var rt = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, rt);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 32, 32, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
				var rb = gl.createRenderbuffer();
				gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
				gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 32, 32);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rt, 0);
				gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rb);
				this.last_capture = new Uint8Array(4);
				// Resize
				this.resize($(window).innerWidth(), $(window).innerHeight());
			};
			glc.resizeCallback = function (w, h) {
				window.movable.screen_diameter = this.screen_diameter = Math.sqrt(w*w + h*h);
				var ir = 1.5/this.screen_diameter;
				this.uPMatrix = M.fromGL4(this.projectionMatrix(ir*w, ir*h, 0.1, 1000));
				window.frame_manager.requestFrame();
			};
			glc.prepareDrawData = function (prog) {
				var gl = glc.gl;
				gl.useProgram(prog);
				// Enable vertex buffers
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertex_buffer);
				var pos = gl.getAttribLocation(prog, 'aVPosition');
				gl.enableVertexAttribArray(pos);
				gl.vertexAttribPointer(pos, 3, gl.FLOAT, false, 44, 0);
				var clr = gl.getAttribLocation(prog, 'aVColor');
				gl.enableVertexAttribArray(clr);
				gl.vertexAttribPointer(clr, 3, gl.FLOAT, false, 44, 12);
				var tex = gl.getAttribLocation(prog, 'aVTexCoord');
				gl.enableVertexAttribArray(tex);
				gl.vertexAttribPointer(tex, 2, gl.FLOAT, false, 44, 24);
				var vid = gl.getAttribLocation(prog, 'aVID');
				if (vid >= 0) {
					gl.enableVertexAttribArray(vid);
					gl.vertexAttribPointer(vid, 3, gl.FLOAT, false, 44, 32);
				}
				// Set uniforms
				gl.uniformMatrix4fv(
					gl.getUniformLocation(prog, 'uPMatrix'),
					false, M.toGL4(this.uPMatrix));
				gl.uniformMatrix4fv(
					gl.getUniformLocation(prog, 'uMVMatrix'),
					false, M.toGL4(
						M.mulMats(window.movable.uBTMatrix,
							window.movable.uMVMatrix))
					);
				gl.uniform2f(gl.getUniformLocation(prog, 'uScale'),
					window.movable.scale, 1/window.movable.scale);
				gl.uniform2fv(gl.getUniformLocation(prog, 'uFog'),
					new Float32Array(window.movable.uFog));
				gl.uniform3f(gl.getUniformLocation(prog, 'uDotSize'),
					window.movable.uDotSize, // straight-up dot size
					-0.25 / window.movable.uVariance, // variance
					0.8 / Math.sqrt(window.movable.uVariance)); // color scaling
				gl.uniform3fv(gl.getUniformLocation(prog, 'uOrigin'),
					new Float32Array(V.add(
					window.movable.uOrigin,
					window.movable.uOriginExtra)));
				gl.uniform3fv(gl.getUniformLocation(prog, 'uOriginColor'),
					new Float32Array(window.movable.uOriginColor));
			};
			glc.pick = function (x, y) {
				var gl = glc.gl;
				gl.disable(gl.BLEND);
				gl.enable(gl.DEPTH_TEST);
				gl.bindFramebuffer(gl.FRAMEBUFFER, glc.frame_buffer);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				glc.prepareDrawData(glc.shaders.picker);
				gl.uniformMatrix4fv(
					gl.getUniformLocation(glc.shaders.picker, 'uPMatrix'),
					false, M.toGL4(M.mulMats([
						[10, 0, 0, 9-10*2*x],
						[0, -10, 0, 9-10*2*y],
						[0, 0, 1, 0],
						[0, 0, 0, 1],
					], this.uPMatrix)));
				gl.uniform3f(gl.getUniformLocation(glc.shaders.picker, 'uDotSize'),
					2*window.movable.uDotSize, // straight-up dot size
					-0.25 / window.movable.uVariance, // variance
					0.8 / Math.sqrt(window.movable.uVariance)); // color scaling
				gl.drawArrays(gl.TRIANGLES, 0, Math.min(glc.num_verts, (1 << 21) * 6 - 6));
				gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, glc.last_capture);
				var clr = Array.prototype.slice.apply(glc.last_capture, []);
				return clr[0] + (clr[1] << 7) + (clr[2] << 14);
			};
			glc.draw = function (time_scheduled) {
				var gl = glc.gl;
				window.movable.update(this.dt);
				window.movable.moveAdjust();
				gl.enable(gl.BLEND);
				gl.disable(gl.DEPTH_TEST);
				gl.bindFramebuffer(gl.FRAMEBUFFER, null);
				gl.clear(gl.COLOR_BUFFER_BIT);
				glc.prepareDrawData(glc.shaders.stars);
				// Debugging...
				//window.movable.pOrigin = M.mul(M.mulMats(glc.uPMatrix,
				//	M.mulMats(window.movable.uBTMatrix, window.movable.uMVMatrix)),
				//	V.scale(window.movable.uOrigin, window.movable.scale).concat(1));
				/*var w = $('#blehbleh')[0].width = $(window).width();
				var h = $('#blehbleh')[0].height = $(window).height();
				var c2 = $('#blehbleh')[0].getContext('2d');
				var m = M.mulMats(glc.uPMatrix,
					M.mulMats(window.movable.uBTMatrix, window.movable.uMVMatrix));
				for (var i = window.movable.selection - 1; i < window.movable.selection; i++) {
					var v = M.mul(m, V.scale(V.add(Array.prototype.slice.apply(glc.glData, [i*54, i*54 + 3]), window.movable.uOrigin), window.movable.scale).concat(1));
					c2.fillStyle = '#ff0';
					if (i != glc.glData[i*54+8] - 1) { c2.fillStyle = '#00f'; }
					if (i == window.movable.selection - 1) { c2.fillStyle = '#f00'; }
					if (v[3] < 0) { continue; }
					fillCircle(c2, w * (1 + v[0]/v[3]) / 2, h * (1 - v[1]/v[3]) / 2, 5);
				}*/
				// Draw!
				gl.drawArrays(gl.TRIANGLES, 0, glc.num_verts);
				if (window.movable.selection && !V.isZero(window.movable.uOriginExtra)) {
					glc.prepareDrawData(glc.shaders.locker);
					gl.uniform3f(gl.getUniformLocation(glc.shaders.locker, 'uDotSize'),
						2*window.movable.uDotSize, 0, 0);
					gl.uniform3fv(gl.getUniformLocation(glc.shaders.locker, 'uOrigin'),
						new Float32Array(window.movable.uOriginExtra));
					gl.drawArrays(gl.TRIANGLES, 0, 6);
				}
				var frame_time = window.performance.now() - time_scheduled;
				if (frame_time < 8) { glc.upLOD(); }
				if (frame_time > 16) { glc.downLOD(); }
				return window.movable.isMoving();
			};
			window.frame_manager = new FrameManager(glc.draw);
			var setupContinue = awaitFlags(7, function () {
				glc.bindCanvas($('#main')[0]);
				window.movable.motionCallback = function () {
					window.frame_manager.requestFrame();
				};
				$(window).on('resize', function (e) {
					glc.resize($(window).width(), $(window).height());
				});
			});
			glc.addProgramByURLs('stars', 'vert.c', 'frag.c', setupContinue.bind(null, 1));
			glc.addProgramByURLs('picker', 'vert.c', 'fpick.c', setupContinue.bind(null, 2));
			glc.addProgramByURLs('locker', 'vert.c', 'flock.c', setupContinue.bind(null, 4));
			window.glc = glc;
			// Init lattice
			var requestMorePoints = (function () {
				var i = 0;
				var BASE_REQUESTS = [
					{type: 'addVerts', iterations: 5},
					{type: 'addVerts', iterations: 5},
					{type: 'addVertsShrink'},
					{type: 'addVertsGrow'},
					{type: 'addVertsGrow'},
					{type: 'addVertsGrow'},
				];
				var finalized = false;
				var end_time = 0;
				return function (neighbor_size) {
					if (finalized) { return; }
					if (!end_time) { end_time = 5000 + (new Date()).valueOf(); }
					if (end_time < (new Date()).valueOf() || neighbor_size < 200) {
						finalized = true;
						window.lattice_worker.postMessage({type: 'addVertsShrink'});
						window.lattice_worker.postMessage({type: 'addVertsGrow'});
					} else {
						if (i < BASE_REQUESTS.length) {
							window.lattice_worker.postMessage(BASE_REQUESTS[i]);
							i++;
						} else {
							window.lattice_worker.postMessage({type: 'addVerts', iterations: 5});
						}
					}
				};
			})();
			window.lattice_worker = new Worker('quasilattice3.js');
			window.lattice_worker.onmessage = function (e) {
				var data = e.data;
				if (data.type == 'update') {
					if (!glc.memory_full) {
						glc.updateData(data.num_verts, data.glData);
					}
					window.movable.translators = data.translators;
					movable.uFog[0] = data.num_verts/36000;
					requestMorePoints((glc.screen_diameter || 512) / Math.sqrt(data.next_weight));
				} else {
					// Show a message box...
				}
			};
			requestMorePoints();
		});
	</script>
</head>
<body>
	<canvas id="main">
		<img src="quasi-thumbnail.png" alt="Preview" />
		This demo requires HTML5 Canvas support.
	</canvas>
	<div id="config" class="overlay"><div class="box">
		<h2>No options available</h2>
		<form method="post" action="#" id="form_config"><div class="formline">
			<a class="button icon button_close" title="Cancel" href="#">&times;</a>
			<label for="config_n" class="icon">&#x21ba;</label>
			<input type="text" class="numeric valid" id="config_n" name="n" value="5" />
			<button type="submit" class="button icon"
				id="config_submit" title="Redraw">&#x00bb;</button>
		</div></form>
	</div></div>
	<div id="help" class="overlay">
		<div class="box">
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<h2>About</h2>
			<p>This page draws the icosahedral 3-dimensional
			<a href="http://en.wikipedia.org/wiki/Quasicrystal"
				>quasicrystal</a>: a thin 3-D slice of a 6-D
			<a href="http://en.wikipedia.org/wiki/Lattice_(group)"
				>lattice</a> with
			<a href="http://en.wikipedia.org/wiki/Icosahedral_symmetry"
				>icosahedral symmetry</a>. Points are sized by
			their proximity to the slice and colored
			by how far they extend into the 3 unrepresented dimensions
			(<span style="color: #fcc;">red</span>,
			<span style="color: #cfc;">green</span>, and
			<span style="color: #ccf;">blue</span>).</p>
			<p>This quasicrystal has two curious properties:
			<ol>
				<li><a href="#help_uniqueness">It's the only 3-D lattice slice
					which is truly 3-D</a>&mdash;all others with any symmetry
					merely repeat a 2-D pattern.</li>
				<li><a href="#help_selfsimilarity">It's self-similar</a>&mdash;a
					zoomed-in view is indistinguishable from a zoomed-out view.</li>
			</ol></p>
			<p>The controls are as follows.
			<ul>
				<li>Turn: arrow keys and &lt;, &gt; or mouse/finger dragging.</li>
				<li>Zoom: "+" and "-", mouse scrolling, or pinch zoom.
					(Hint: lock onto a point first.)</li>
				<li>Fly: spacebar and Z or press-and-hold.</li>
				<li>Lock onto a point: double-tap.</li>
				<li>Toggle first-person view: triple-tap.</li>
			</ul></p>
			<p>Code written by <a href="http://pteromys.melonisland.net/">Pteromys</a>
			and released under the <a href="http://unlicense.org/">Unlicense</a>.</p>
		</div>
	</div>
	<div id="help_selfsimilarity" class="overlay">
		<div class="box">
			<a class="button icon button_leftmargin"
				title="Back" href="#help">&laquo;</a>
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<h2>Self-similarity</h2>
			<p>Zooming in expands space by some factor \(s\).
			To compensate for the spreading out of dots,
			we'll make more dots touch our slice
			by scaling the unseen 3 dimensions by
			\(\frac{1}{s}\) (to keep the number of dots
			drawn roughly constant).</p>
			<p>If \(s = 2 + \sqrt{5}\), a miracle occurs: all dots
			land on other dots, and it's as if we never zoomed in.
			To understand why, we need to describe the 6-D
			lattice in more detail.</p>
			<p>Let \(\zeta\) be the 5th
			<a href="http://en.wikipedia.org/wiki/Root_of_unity"
				>root of unity</a> \(e^{2\pi i/5}\).
			In \(\mathbf{R} \times \mathbf{C}\), the points
				\[ \pm(\sqrt{5}, 0), \pm(1, 2\zeta^k) \]
			(\(k = 0\) to \(4\)) are the twelve vertices of an icosahedron,
			and their sums are the dots we see.
			The unseen 3 dimensions are
			a second set of \(\mathbf{R} \times \mathbf{C}\)
			coordinates that replace \(\zeta\) with the
			<a href="http://en.wikipedia.org/wiki/Conjugate_element_(field_theory)"
				>algebraically indistinguishable</a> \(\zeta^2\).
			As \(\sqrt{5} = 1 + 2(\zeta + \zeta^{-1})\), this also ends up
			replacing \(\sqrt{5}\) by \(-\sqrt{5}\).
			You can check using
			<a href="http://en.wikipedia.org/wiki/Dot_product">dot products</a>
			that the twelve vertices now point in six perpendicular directions
			in the 6-D combined coordinate system.</p>
			<p>Scaling by \(2 + \sqrt{5}\) in the first two coordinates
			amounts to replacing each vertex with the sum of
			twice itself and its five neighbors&mdash;thus taking dots
			to other dots.
			In the last two coordinates, this becomes scaling by \(2 - \sqrt{5}\),
			and the miracle stems from the fact that
				\[ (2 + \sqrt{5})(2 - \sqrt{5}) = -1 . \]
			That is, this scaling is what we'd obtain with a zoom factor
			of \(2 + \sqrt{5}\).
			</p>
		</div>
	</div>
	<div id="help_uniqueness" class="overlay">
		<div class="box">
			<a class="button icon button_leftmargin"
				title="Back" href="#help">&laquo;</a>
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<h2>Uniqueness</h2>
			<p>What we're looking for is a group of symmetries \(G\)
			of a higher-dimensional lattice \(\mathbf{Z}^n \subset \mathbf{R}^n\),
			along with a 3-plane \(V \subset \mathbf{R}^n\) (the slice)
			on which \(G\) acts irreducibly (the non-2-D condition,
			which amounts to not having an axis).</p>
			<p>Of the <a
				href="http://en.wikipedia.org/wiki/Point_groups_in_three_dimensions#The_seven_remaining_point_groups"
				>seven non-axial point groups in 3 dimensions</a>,
			only the two icosahedral groups don't already
			preserve an ordinary 3-D lattice. These are the
			<a href="http://en.wikipedia.org/wiki/Alternating_group"
				>alternating group</a> \(A_5\) and the product
			\(A_5 \times \{\pm 1\}\); so it suffices to find
			<a href="http://groupprops.subwiki.org/wiki/Linear_representation_theory_of_alternating_group:A5"
				>a list of representations</a>
			of \(A_5\) over integers and real numbers.</p>
			<p>(One detail remains: \(A_5\) might only
			be the quotient of \(G\) by a normal subgroup \(N\).
			Fortunately, the map
				\[ x \mapsto \sum_{g \in N} gx \]
			is an endomorphism of \(\mathbf{Z}^n\)
			on whose image \(A_5\) acts.)</p>
		</div>
	</div>
	<a class="button icon button_root"
		href="#help" id="button_help" title="Help">?</a>
	<a class="button icon button_root"
		href="#config" id="button_config" title="Settings">&#x2699;</a>
</body>
</html>
