<!doctype html>
<html lang="en">
<head>
	<title>Quasicrystals</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="icons/webfont.css" />
	<link rel="stylesheet" type="text/css" href="interface.css" />
	<style type="text/css">
		html, body { width: 100%; height: 100%; margin: 0px; padding: 0px; }
		body { background: #000; }
		canvas {
			position: absolute;
			top: 0px; left: 0px; bottom: 0px; right: 0px;
		}
		#config .box { text-align: center; }
		.formline { margin: 0.5em -1em 0em; }
		.formline .button { margin: 0em 0.25em; }
	</style>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript" src="heap.js"></script>
	<script type="text/javascript" src="linear.js"></script>
	<script type="text/javascript" src="motion.js"></script>
	<script type="text/javascript" src="frames.js"></script>
	<script type="text/javascript" src="interface.js"></script>
	<script type="text/javascript" src="gl.js"></script>
	<script type="text/javascript" src="icos.js"></script>
	<script type="text/javascript">
		// Constants
		var EPSILON = 1e-9;

		// Vertices in the quasi-lattice
		var Vertex = function (indices) {
			this.indices = indices.slice();
			this.coords = M.mul(Icos.BASIS, indices);
			this.is_fundamental = Icos.isFundamental(this.coords);
			var c = this.coords;
			this.r2 = c[0]*c[0] + c[1]*c[1] + c[2]*c[2];
			this.d2 = c[3]*c[3] + c[4]*c[4] + c[5]*c[5];
			this.weight = this.r2 + this.d2;
		};
		var QuasiLattice3 = function () {
			this.verts = [];
			this.glData = [];
			this.border_verts = new Heap([], this.vertCmp);
			this.vert_names = {};
			this.directions = [];
			this.direction_threshold = Infinity;
			this.addVertSymmetric([0,0,0,0,0,0]);
			this.direction_threshold = Infinity;
			this.addVertSymmetric([1,0,0,0,0,0]);
		};
		QuasiLattice3.prototype = {
			vertCmp: function (a, b) { return a.weight < b.weight; },
			addVert: function (indices) {
				var name = indices.join(' ');
				if (this.vert_names[name]) { return false; }
				var nv = new Vertex(indices);
				this.verts.push(nv);
				this.vert_names[name] = nv;
				if (Icos.isFundamental(nv.coords)) {
					this.border_verts.push(nv);
				}
				this.glData.push(nv.coords[0], nv.coords[1], nv.coords[2],
					nv.coords[3], nv.coords[4], nv.coords[5]);
				return nv;
			},
			addVertSymmetric: function (indices) {
				var dt = this.direction_threshold;
				for (var i = 0; i < Icos.GROUP.length; i++) {
					var nv = this.addVert(M.mul(Icos.GROUP[i], indices));
					if (nv) {
						if (nv.d2 < dt + EPSILON) {
							this.directions.push(nv);
							this.direction_threshold = nv.d2;
							new_direction = true;
						}
					}
				}
			},
			addVerts: function (v) {
				if (!v) {
					v = this.border_verts.pop();
					if (!v) { return false; }
				}
				var nv;
				var c = this.verts.length;
				for (var i = 1; i < this.directions.length; i++) {
					nv = V.add(v.indices, this.directions[i].indices);
					this.addVertSymmetric(nv);
				}
				return this.verts.length - c;
			},
			addVertsByTransform: function (steps, limit) {
				steps = steps || 1;
				limit = limit || this.verts.length;
				// Set up matrices to transform by
				var t = Icos.M_EXPAND;
				var ti = Icos.M_SHRINK;
				var mats = [];
				for (var j = 1; j < steps; j++) {
					mats.push(t);
					mats.push(ti);
					t = M.mulMats(Icos.M_EXPAND, t);
					ti = M.mulMats(Icos.M_SHRINK, ti);
				}
				// Add verts
				for (var i = 0; i < limit; i++) {
					if (this.verts[i].is_fundamental) {
						for (var j = 0; j < mats.length; j++) {
							this.addVertSymmetric(M.mul(mats[j], this.verts[i].indices));
						}
					}
				}
			},
		};

		$(document).ready(function () {
			// Init lattice
			window.q = new QuasiLattice3();
			for (var i = 0; i < 35; i++) {
				q.addVerts();
				//q.addVertsByTransform(2);
			}
			q.addVertsByTransform(2);
			// Motion
			window.movable = new Movable();
			window.movable.velocity_keys[1] = [window.movable.KEYS.DOWN, window.movable.KEYS.UP];
			window.movable.velocity_keys[2] = [window.movable.KEYS.S, window.movable.KEYS.W];
			window.movable.velocity_keys[3] = [window.movable.KEYS.Z, window.movable.KEYS.A];
			movable.canAccelerate = function () {
				return !($('.overlay').is(':target'));
			};
			movable.bindHandlers(window);
			movable.scaled_position = [0, 0];
			movable.moveResetSuper = window.movable.moveReset;
			movable.moveReset = function () {
				this.moveResetSuper();
				this.angle_xz = 0;
				this.angle_zy = 0;
				this.radius = 2;
				this.scale = 1.0;
				this.uOrigin = [0, 0, 0];
				this.uOriginColor = [0, 0, 0];
				this.uFog = [10, -1];
			};
			movable.moveReset();
			// Animation
			var glc = new GLWrapper();
			// I don't know where to put these yet
			var MAX_SCALE = 2 + Math.sqrt(5);
			// Set up
			glc.setupState = function () {
				var gl = this.gl;
				gl.clearColor(0, 0, 0, 0);
				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
				// Upload data
				this.vertex_buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertex_buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(q.glData), gl.STATIC_DRAW);
				// Resize
				this.resize($(window).innerWidth(), $(window).innerHeight());
			};
			glc.resizeCallback = function (w, h) {
				var ir = 1.5/Math.sqrt(w*w + h*h);
				this.uPMatrix = M.fromGL4(this.projectionMatrix(ir*w, ir*h, 0.1, 1000));
				window.frame_manager.requestFrame();
			};
			glc.draw = function (time_scheduled) {
				var gl = glc.gl;
				var prog = glc.shaders.stars;
				window.movable.update(this.dt);
				gl.clear(gl.COLOR_BUFFER_BIT);
				gl.useProgram(prog);
				// Enable vertex buffers
				gl.bindBuffer(gl.ARRAY_BUFFER, glc.vertex_buffer);
				var pos = gl.getAttribLocation(prog, 'aVPosition');
				gl.enableVertexAttribArray(pos);
				gl.vertexAttribPointer(pos, 3, gl.FLOAT, false, 24, 0);
				var clr = gl.getAttribLocation(prog, 'aVColor');
				gl.enableVertexAttribArray(clr);
				gl.vertexAttribPointer(clr, 3, gl.FLOAT, false, 24, 12);
				// Set uniforms
				// Matrix entries by column left-to-right, down each column.
				gl.uniformMatrix4fv(
					gl.getUniformLocation(prog, 'uPMatrix'),
					false, M.toGL4(
						M.mulMats(glc.uPMatrix,
						M.mulMats(glc.uBTMatrix,
							glc.uMVMatrix))
					));
				gl.uniform2f(gl.getUniformLocation(prog, 'uScale'), window.movable.scale, 1/window.movable.scale);
				gl.uniform2fv(gl.getUniformLocation(prog, 'uFog'),
					new Float32Array(window.movable.uFog));
				gl.uniform3fv(gl.getUniformLocation(prog, 'uOrigin'),
					new Float32Array(window.movable.uOrigin));
				gl.uniform3fv(gl.getUniformLocation(prog, 'uOriginColor'),
					new Float32Array(window.movable.uOriginColor));
				// Draw!
				gl.drawArrays(gl.POINTS, 0, q.verts.length);
			};
			window.frame_manager = new FrameManager(glc.draw);
			glc.addProgramByURLs('stars', 'vert.c', 'frag.c', function () {
				glc.bindCanvas($('#main')[0]);
				glc.updateMatrices();
			});
			window.glc = glc;
			glc.updateMatrices = function () {
				var w = $(window).width();
				var h = $(window).height()/2;
				movable.position[0] %= w;
				movable.position[1] = Math.max(-h, Math.min(movable.position[1], h));
				movable.scaled_position[0] = 2 * Math.PI * movable.position[0] / w;
				movable.scaled_position[1] = 0.5 * Math.PI * movable.position[1] / h;
				movable.angle_xz = movable.scaled_position[0];
				movable.angle_zy = -movable.scaled_position[1];
				var cxz = Math.cos(movable.angle_xz);
				var sxz = Math.sin(movable.angle_xz);
				var czy = Math.cos(movable.angle_zy);
				var szy = Math.sin(movable.angle_zy);
				glc.uMVMatrix = [
					[cxz,        0,    sxz,       0],
					[-sxz * szy, czy,  cxz * szy, 0],
					[-sxz * czy, -szy, cxz * czy, 0], // -movable.radius,
					[0,          0,    0,         1],
				];
				glc.uBTMatrix = [
					[1,0,0,0],
					[0,1,0,0],
					[0,0,1,-window.movable.radius],
					[0,0,0,1]
				];
			};
			movable.moveSuper = movable.move;
			movable.move = function (dt) {
				// Shift positions
				this.moveSuper(dt);
				// Translation
				if (this.velocity[2]) {
					this.uOrigin = V.add(
						M.mul(M.transpose(glc.uMVMatrix),
							[0, 0, dt * this.velocity[2] * 0.01 / this.scale]),
						this.uOrigin);
				}
				// Zooming
				this.scale = this.scale || 1.0;
				if (this.velocity[3]) {
					this.scale *= Math.exp(dt * this.velocity[3] * 0.002);
				}
				var s2 = this.scale * this.scale;
				if (s2 > MAX_SCALE) {
					this.scale /= MAX_SCALE;
					this.uOrigin = V.scale(this.uOrigin, MAX_SCALE);
					this.uOriginColor = V.scale(this.uOriginColor, -1/MAX_SCALE);
				} else if (s2 * MAX_SCALE < 1) {
					this.scale *= MAX_SCALE;
					this.uOrigin = V.scale(this.uOrigin, 1/MAX_SCALE);
					this.uOriginColor = V.scale(this.uOriginColor, -MAX_SCALE);
				}
				// Recentering
				window.bleh = function (x, y) {
					return x + y;
				}
				var s2 = this.scale * this.scale;
				function dirNiceness(v) {
					var x = V.add(v.coords.slice(0,3), window.movable.uOrigin);
					var y = V.add(v.coords.slice(3,6), window.movable.uOriginColor);
					x = V.dot(x, x) * s2;
					y = V.dot(y, y) / s2;
					return window.bleh(x,y);
				}
				var new_niceness = Infinity;
				var niceness = Infinity;
				var dir = q.directions[0];
				for (var i = 0; i < q.directions.length; i++) {
					new_niceness = dirNiceness(q.directions[i]);
					if (new_niceness < niceness) {
						dir = q.directions[i];
						niceness = new_niceness;
					}
				}
				this.uOrigin = V.add(dir.coords.slice(0,3), this.uOrigin);
				this.uOriginColor = V.add(dir.coords.slice(3,6), this.uOriginColor);
			};
			movable.motionCallback = function () {
				glc.updateMatrices();
				window.frame_manager.requestFrame();
			};
			$(window).on('resize', function (e) {
				glc.resize($(window).width(), $(window).height());
			});
		});
	</script>
</head>
<body>
	<canvas id="main" class="active">
		<img src="quasi-thumbnail.png" alt="Preview" />
		This demo requires HTML5 Canvas support.
	</canvas>
	<div id="config" class="overlay"><div class="box">
		<h2>No options available</h2>
		<form method="post" action="#" id="form_config"><div class="formline">
			<a class="button icon button_close" title="Cancel" href="#">&times;</a>
			<label for="config_n" class="icon">&#x21ba;</label>
			<input type="text" class="numeric valid" id="config_n" name="n" value="5" />
			<button type="submit" class="button icon"
				id="config_submit" title="Redraw">&#x00bb;</button>
		</div></form>
	</div></div>
	<div id="help" class="overlay">
		<div class="box">
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<p>This page draws patterns reminiscient of quasicrystals
			by projecting higher-dimensional lattices into the plane.
			<p>Code written by <a href="http://pteromys.melonisland.net/">Pteromys</a>
			and released under the <a href="http://unlicense.org/">Unlicense</a>.</p>
		</div>
	</div>
	<a class="button icon button_root"
		href="#help" id="button_help" title="Help">?</a>
	<a class="button icon button_root"
		href="#config" id="button_config" title="Settings">&#x2699;</a>
</body>
</html>
