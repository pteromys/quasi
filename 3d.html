<!doctype html>
<html lang="en">
<head>
	<title>Quasicrystals</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="icons/webfont.css" />
	<link rel="stylesheet" type="text/css" href="interface.css" />
	<style type="text/css">
		html, body { width: 100%; height: 100%; margin: 0px; padding: 0px; }
		body { background: #000; }
		canvas {
			position: absolute;
			top: 0px; left: 0px; bottom: 0px; right: 0px;
		}
		#config .box { text-align: center; }
		.box {
			background: rgba(15, 15, 15, 0.9);
			box-shadow: 0em 0em 2em 0em rgba(255, 255, 255, 0.5);
		}
		h2 { text-align: center; }
		.formline { margin: 0.5em -1em 0em; }
		.formline .button { margin: 0em 0.25em; }
	</style>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript" src="heap.js"></script>
	<script type="text/javascript" src="linear.js"></script>
	<script type="text/javascript" src="motion.js"></script>
	<script type="text/javascript" src="frames.js"></script>
	<script type="text/javascript" src="interface.js"></script>
	<script type="text/javascript" src="gl.js"></script>
	<script type="text/javascript" src="icos.js"></script>
	<script type="text/javascript">
		// Constants
		var EPSILON = 1e-9;

		// Vertices in the quasi-lattice
		var Vertex = function (indices) {
			this.indices = indices.slice();
			this.coords = M.mul(Icos.BASIS, indices);
			this.is_fundamental = Icos.isFundamental(this.coords);
			var c = this.coords;
			this.r2 = c[0]*c[0] + c[1]*c[1] + c[2]*c[2];
			this.d2 = c[3]*c[3] + c[4]*c[4] + c[5]*c[5];
			this.weight = this.r2 + this.d2;
		};
		var QuasiLattice3 = function () {
			this.verts = [];
			this.glData = [];
			this.border_verts = new Heap([], this.vertCmp);
			this.vert_names = {};
			this.directions = [];
			this.direction_threshold = Infinity;
			this.addVertSymmetric([0,0,0,0,0,0]);
			this.direction_threshold = Infinity;
			this.addVertSymmetric([1,0,0,0,0,0]);
		};
		QuasiLattice3.prototype = {
			vertCmp: function (a, b) { return a.weight < b.weight; },
			addVert: function (indices) {
				var name = indices.join(' ');
				if (this.vert_names[name]) { return false; }
				var nv = new Vertex(indices);
				this.verts.push(nv);
				this.vert_names[name] = nv;
				if (Icos.isFundamental(nv.coords)) {
					this.border_verts.push(nv);
				}
				this.glData.push(nv.coords[0], nv.coords[1], nv.coords[2],
					nv.coords[3], nv.coords[4], nv.coords[5]);
				return nv;
			},
			addVertSymmetric: function (indices) {
				var dt = this.direction_threshold;
				for (var i = 0; i < Icos.GROUP.length; i++) {
					var nv = this.addVert(M.mul(Icos.GROUP[i], indices));
					if (nv) {
						if (nv.d2 < dt + EPSILON) {
							this.directions.push(nv);
							this.direction_threshold = nv.d2;
							new_direction = true;
						}
					}
				}
			},
			addVerts: function (v) {
				if (!v) {
					v = this.border_verts.pop();
					if (!v) { return false; }
				}
				var nv;
				var c = this.verts.length;
				for (var i = 1; i < this.directions.length; i++) {
					nv = V.add(v.indices, this.directions[i].indices);
					this.addVertSymmetric(nv);
				}
				return this.verts.length - c;
			},
			addVertsByTransform: function (steps, limit) {
				steps = steps || 1;
				limit = limit || this.verts.length;
				// Set up matrices to transform by
				var t = Icos.M_EXPAND;
				var ti = Icos.M_SHRINK;
				var mats = [];
				for (var j = 1; j < steps; j++) {
					mats.push(t);
					mats.push(ti);
					t = M.mulMats(Icos.M_EXPAND, t);
					ti = M.mulMats(Icos.M_SHRINK, ti);
				}
				// Add verts
				for (var i = 0; i < limit; i++) {
					if (this.verts[i].is_fundamental) {
						for (var j = 0; j < mats.length; j++) {
							this.addVertSymmetric(M.mul(mats[j], this.verts[i].indices));
						}
					}
				}
			},
		};

		$(document).ready(function () {
			// Init buttons
			ButtonSystem.activateKeys({191: '#button_help'});
			// Init lattice
			window.q = new QuasiLattice3();
			for (var i = 0; i < 35; i++) {
				q.addVerts();
				//q.addVertsByTransform(2);
			}
			q.addVertsByTransform(2);
			// Motion
			window.movable = new Movable();
			window.movable.velocity_keys[1] = [window.movable.KEYS.DOWN, window.movable.KEYS.UP];
			window.movable.velocity_keys[2] = [window.movable.KEYS.S, window.movable.KEYS.W];
			window.movable.velocity_keys[3] = [window.movable.KEYS.Z, window.movable.KEYS.A];
			movable.canAccelerate = function () {
				return !($('.overlay').is(':target'));
			};
			movable.bindHandlers(window);
			movable.scaled_position = [0, 0];
			movable.moveResetSuper = window.movable.moveReset;
			movable.moveReset = function () {
				this.moveResetSuper();
				this.radius = 2;
				this.scale = 1.0;
				this.uOrigin = [0, 0, 0];
				this.uOriginColor = [0, 0, 0];
				this.uFog = [10, -1];
				this.uMVMatrix = [
					[1,0,0,0],
					[0,1,0,0],
					[0,0,1,0],
					[0,0,0,1]
				];
				this.uBTMatrix = [
					[1,0,0,0],
					[0,1,0,0],
					[0,0,1,-this.radius],
					[0,0,0,1]
				];
			};
			movable.moveReset();
			// Animation
			var glc = new GLWrapper();
			// I don't know where to put these yet
			var MAX_SCALE = 2 + Math.sqrt(5);
			// Set up
			glc.setupCallback = function () {
				var gl = this.gl;
				gl.clearColor(0, 0, 0, 0);
				gl.enable(gl.BLEND);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
				// Upload data
				this.vertex_buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.vertex_buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(q.glData), gl.STATIC_DRAW);
				// Resize
				this.resize($(window).innerWidth(), $(window).innerHeight());
			};
			glc.resizeCallback = function (w, h) {
				this.screen_radius = Math.sqrt(w*w + h*h);
				var ir = 1.5/this.screen_radius;
				this.uPMatrix = M.fromGL4(this.projectionMatrix(ir*w, ir*h, 0.1, 1000));
				window.frame_manager.requestFrame();
			};
			glc.draw = function (time_scheduled) {
				var gl = glc.gl;
				var prog = glc.shaders.stars;
				window.movable.update(this.dt);
				gl.clear(gl.COLOR_BUFFER_BIT);
				gl.useProgram(prog);
				// Enable vertex buffers
				gl.bindBuffer(gl.ARRAY_BUFFER, glc.vertex_buffer);
				var pos = gl.getAttribLocation(prog, 'aVPosition');
				gl.enableVertexAttribArray(pos);
				gl.vertexAttribPointer(pos, 3, gl.FLOAT, false, 24, 0);
				var clr = gl.getAttribLocation(prog, 'aVColor');
				gl.enableVertexAttribArray(clr);
				gl.vertexAttribPointer(clr, 3, gl.FLOAT, false, 24, 12);
				// Set uniforms
				// Matrix entries by column left-to-right, down each column.
				gl.uniformMatrix4fv(
					gl.getUniformLocation(prog, 'uPMatrix'),
					false, M.toGL4(
						M.mulMats(glc.uPMatrix,
						M.mulMats(window.movable.uBTMatrix,
							window.movable.uMVMatrix))
					));
				gl.uniform2f(gl.getUniformLocation(prog, 'uScale'), window.movable.scale, 1/window.movable.scale);
				gl.uniform2fv(gl.getUniformLocation(prog, 'uFog'),
					new Float32Array(window.movable.uFog));
				gl.uniform3fv(gl.getUniformLocation(prog, 'uOrigin'),
					new Float32Array(window.movable.uOrigin));
				gl.uniform3fv(gl.getUniformLocation(prog, 'uOriginColor'),
					new Float32Array(window.movable.uOriginColor));
				// Draw!
				gl.drawArrays(gl.POINTS, 0, q.verts.length);
			};
			window.frame_manager = new FrameManager(glc.draw);
			glc.addProgramByURLs('stars', 'vert.c', 'frag.c', function () {
				glc.bindCanvas($('#main')[0]);
			});
			window.glc = glc;
			movable.move = function (dt) {
				// Rotation
				var yaw = 2 * Math.PI * this.velocity[0] * dt / glc.screen_radius;
				var pitch = -2 * Math.PI * this.velocity[1] * dt / glc.screen_radius;
				var cxz = Math.cos(yaw);
				var sxz = Math.sin(yaw);
				var czy = Math.cos(pitch);
				var szy = Math.sin(pitch);
				this.uMVMatrix = M.mulMats([
					[cxz,        0,    sxz,       0],
					[-sxz * szy, czy,  cxz * szy, 0],
					[-sxz * czy, -szy, cxz * czy, 0], // -movable.radius,
					[0,          0,    0,         1],
				], this.uMVMatrix);
				// Translation
				if (this.velocity[2]) {
					this.uOrigin = V.add(
						M.mul(M.transpose(this.uMVMatrix),
							[0, 0, dt * this.velocity[2] * 0.01 / this.scale]),
						this.uOrigin);
				}
				// Zooming
				this.scale = this.scale || 1.0;
				if (this.velocity[3]) {
					this.scale *= Math.exp(dt * this.velocity[3] * 0.002);
				}
				var s2 = this.scale * this.scale;
				if (s2 > MAX_SCALE) {
					this.scale /= MAX_SCALE;
					this.uOrigin = V.scale(this.uOrigin, MAX_SCALE);
					this.uOriginColor = V.scale(this.uOriginColor, -1/MAX_SCALE);
				} else if (s2 * MAX_SCALE < 1) {
					this.scale *= MAX_SCALE;
					this.uOrigin = V.scale(this.uOrigin, 1/MAX_SCALE);
					this.uOriginColor = V.scale(this.uOriginColor, -MAX_SCALE);
				}
				// Recentering
				window.bleh = function (x, y) {
					return x + y;
				}
				var s2 = this.scale * this.scale;
				function dirNiceness(v) {
					var x = V.add(v.coords.slice(0,3), window.movable.uOrigin);
					var y = V.add(v.coords.slice(3,6), window.movable.uOriginColor);
					x = V.dot(x, x) * s2;
					y = V.dot(y, y) / s2;
					return window.bleh(x,y);
				}
				var new_niceness = Infinity;
				var niceness = Infinity;
				var dir = q.directions[0];
				for (var i = 0; i < q.directions.length; i++) {
					new_niceness = dirNiceness(q.directions[i]);
					if (new_niceness < niceness) {
						dir = q.directions[i];
						niceness = new_niceness;
					}
				}
				this.uOrigin = V.add(dir.coords.slice(0,3), this.uOrigin);
				this.uOriginColor = V.add(dir.coords.slice(3,6), this.uOriginColor);
			};
			movable.motionCallback = function () {
				window.frame_manager.requestFrame();
			};
			$(window).on('resize', function (e) {
				glc.resize($(window).width(), $(window).height());
			});
		});
	</script>
</head>
<body>
	<canvas id="main" class="active">
		<img src="quasi-thumbnail.png" alt="Preview" />
		This demo requires HTML5 Canvas support.
	</canvas>
	<div id="config" class="overlay"><div class="box">
		<h2>No options available</h2>
		<form method="post" action="#" id="form_config"><div class="formline">
			<a class="button icon button_close" title="Cancel" href="#">&times;</a>
			<label for="config_n" class="icon">&#x21ba;</label>
			<input type="text" class="numeric valid" id="config_n" name="n" value="5" />
			<button type="submit" class="button icon"
				id="config_submit" title="Redraw">&#x00bb;</button>
		</div></form>
	</div></div>
	<div id="help" class="overlay">
		<div class="box">
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<p>This page draws the icosahedral 3-dimensional
			<a href="http://en.wikipedia.org/wiki/Quasicrystal"
				>quasicrystal</a>: a thin 3-D slice of a 6-D
			<a href="http://en.wikipedia.org/wiki/Lattice_(group)"
				>lattice</a> with
			<a href="http://en.wikipedia.org/wiki/Icosahedral_symmetry"
				>icosahedral symmetry</a>. Points are sized by
			their proximity to the slice and colored
			by how far they extend into the 3 unrepresented dimensions
			(<span style="color: #fcc;">red</span>,
			<span style="color: #cfc;">green</span>, and
			<span style="color: #ccf;">blue</span>).</p>
			<p>This quasicrystal has two curious properties:
			<ol>
				<li><a href="#help_uniqueness">It's the only 3-D lattice slice
					which is truly 3-D</a>&mdash;all others with any symmetry
					merely repeat a 2-D pattern.</li>
				<li><a href="#help_selfsimilarity">It's self-similar</a>&mdash;a
					zoomed-in view is indistinguishable from a zoomed-out view.</li>
			</ol></p>
			<p>The controls are as follows.
			<ul>
				<li>Turning: arrow keys, mouse dragging, or two-finger swipe.</li>
				<li>Zooming: "+" and "-", mouse scrolling, or pinch zoom.</li>
				<li>Fly around: spacebar and backspace, shift-click, or one-finger swipe.</li>
			</ul></p>
			<p>Code written by <a href="http://pteromys.melonisland.net/">Pteromys</a>
			and released under the <a href="http://unlicense.org/">Unlicense</a>.</p>
		</div>
	</div>
	<div id="help_selfsimilarity" class="overlay">
		<div class="box">
			<a class="button icon button_close button_leftmargin"
				title="Back" href="#help">&laquo;</a>
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<h2>Self-similarity</h2>
			<p>Zooming in expands space by some scale factor \(s\).
			This spreads out the dots, but we can compensate
			by shrinking the unseen 3 dimensions to make more dots
			touch our slice.
			To keep the number of dots roughly constant,
			let's shrink the unseen dimensions by \(s\).</p>
			<p>If \(s = 2 + \sqrt{5}\), then a miracle occurs: all dots
			land on other dots, and it's like we never zoomed in at all.
			To see why this happens we're going to need to describe the 6-D
			lattice in more detail:</p>
			<p>If \(\zeta\) is the 5th
			<a href="http://en.wikipedia.org/wiki/Root_of_unity">root of unity</a>
			\(e^{2\pi i/5}\), then \(\sqrt{5} = 1 + 2(\zeta + \zeta^{-1})\),
			and the points in
			\(\mathbf{R} \times \mathbf{C} \times \mathbf{R} \times \mathbf{C}\)
			named by
				\[ (1, 0, 1, 0), \\
				\left(\frac{1}{\sqrt{5}}, \frac{2\zeta^k}{\sqrt{5}},
				-\frac{1}{\sqrt{5}}, -\frac{2\zeta^{2k}}{\sqrt{5}}\right) \]
			(with \(k\) going from \(0\) to \(4\))
			form the basis of a lattice (you can check with
			<a href="http://en.wikipedia.org/wiki/Dot_product">dot products</a>
			that they're mutually perpendicular).</p>
			<p>The last two coordinates are obtained from the first two
			by replacing \(\zeta\) with the
			<a href="http://en.wikipedia.org/wiki/Conjugate_element_(field_theory)"
			>algebraically indistinguishable</a>
			\(\zeta^2\), which also replaces \(\sqrt{5}\) by \(-\sqrt{5}\).</p>
			<p>Taking only the first two coordinates yields 6 vertices
			of an icosahedron; and scaling by \(2 + \sqrt{5}\)
			amounts to replacing each vertex with the sum of
			twice itself and its five neighbors&mdash;thus taking dots
			to other dots.
			This replacement scheme is reflected in the last two coordinates
			as scaling by \(2 - \sqrt{5}\); and we were able to reach this
			state of affairs by zooming because
				\[ (2 + \sqrt{5})(2 - \sqrt{5}) = -1 . \]
			</p>
		</div>
	</div>
	<div id="help_uniqueness" class="overlay">
		<div class="box">
			<a class="button icon button_close button_leftmargin"
				title="Back" href="#help">&laquo;</a>
			<a class="button icon button_close button_rightmargin"
				title="Close" href="#">&times;</a>
			<h2>Uniqueness</h2>
			<p>What we're looking for is a group of symmetries \(G\)
			of a higher-dimensional lattice \(\mathbf{Z}^n \subset \mathbf{R}^n\),
			along with a 3-plane \(V \subset \mathbf{R}^n\) (the slice)
			on which \(G\) acts irreducibly (the non-2-D condition,
			which amounts to not having an axis).</p>
			<p>Of the <a
				href="http://en.wikipedia.org/wiki/Point_groups_in_three_dimensions#The_seven_remaining_point_groups"
				>seven non-axial point groups in 3 dimensions</a>,
			only the two icosahedral groups don't already
			preserve an ordinary 3-D lattice. These are the
			<a href="http://en.wikipedia.org/wiki/Alternating_group"
				>alternating group</a> \(A_5\) and the product
			\(A_5 \times \{\pm 1\}\); so it suffices to find
			<a href="http://groupprops.subwiki.org/wiki/Linear_representation_theory_of_alternating_group:A5"
				>a list of representations</a>
			of \(A_5\) over integers and real numbers.</p>
			<p>(One detail remains: \(A_5\) might only
			be the quotient of \(G\) by a normal subgroup \(N\).
			Fortunately, the map
				\[ x \mapsto \sum_{g \in N} gx \]
			is an endomorphism of \(\mathbf{Z}^n\)
			on whose image \(A_5\) acts.)</p>
		</div>
	</div>
	<a class="button icon button_root"
		href="#help" id="button_help" title="Help">?</a>
	<a class="button icon button_root"
		href="#config" id="button_config" title="Settings">&#x2699;</a>
</body>
</html>
